File Name: __init__.py
========================================

========================================

File Name: chainlit\chainlit.py
========================================

========================================

File Name: streamlit\config.py
========================================
# API endpoint configurations
API_BASE_URL = "http://localhost:8000"

# Database operations endpoints
DB_ENDPOINTS = {
    "create": f"{API_BASE_URL}/chromadb/create",
    "delete": f"{API_BASE_URL}/chromadb/delete",
    "create_collection": f"{API_BASE_URL}/chromadb/collections",  # /{collection_name}
    "delete_collection": f"{API_BASE_URL}/chromadb/collections",  # /{collection_name}
    "list_collections": f"{API_BASE_URL}/chromadb/collections",
}

# Index operations endpoints
INDEX_ENDPOINTS = {
    "add_documents": f"{API_BASE_URL}/chroma",  # /{collection_name}/add_documents
    "search": f"{API_BASE_URL}/chroma",  # /{collection_name}/search
    "delete_document": f"{API_BASE_URL}/chroma",  # /{collection_name}/documents/{document_id}
    "update_document": f"{API_BASE_URL}/chroma",  # /{collection_name}/documents/{document_id}
    "count": f"{API_BASE_URL}/chroma",  # /{collection_name}/count
    "process_pdfs": f"{API_BASE_URL}/chroma",  # /{collection_name}/process_pdfs
    "process_folder": f"{API_BASE_URL}/chroma",  # /{collection_name}/process_folder
}

# Google Drive endpoints
GDRIVE_ENDPOINTS = {
    "authorize": f"{API_BASE_URL}/gdrive/authorize",
    "oauth2callback": f"{API_BASE_URL}/gdrive/oauth2callback",
    "download_files": f"{API_BASE_URL}/gdrive/download_files",  # /{folder_id}
}

# Styling configurations
STYLES = {
    "success_color": "#0FBA81",
    "error_color": "#FF4B4B",
    "warning_color": "#FFA726",
    "info_color": "#2196F3",
}
========================================

File Name: streamlit\Home.py
========================================
import streamlit as st

st.set_page_config(
    page_title="AIIP RAG Agents",
    page_icon="ü§ñ",
    layout="wide"
)

st.title("Welcome to AIIP RAG Agents! ü§ñ")

st.markdown("""
### Navigate using the sidebar to:
1. üóÑÔ∏è **Database Operations**: Manage ChromaDB databases and collections
2. üìë **Index Operations**: Process and index documents
3. üí¨ **Agent Chat**: Interact with RAG agents

Choose an option from the sidebar to get started!
""")


========================================

File Name: streamlit\__init__.py
========================================

========================================

File Name: streamlit\components\status.py
========================================
import streamlit as st
from typing import Optional

def show_status_message(
    message: str,
    type: str = "info",
    duration: Optional[int] = None,
    key: Optional[str] = None
):
    """
    Display a status message using Streamlit.
    
    Args:
        message: Message to display
        type: Type of message (success, error, warning, info)
        duration: Duration to show message in seconds
        key: Unique key for the message
    """
    if type == "success":
        st.success(message, icon="‚úÖ")
    elif type == "error":
        st.error(message, icon="üö®")
    elif type == "warning":
        st.warning(message, icon="‚ö†Ô∏è")
    else:
        st.info(message, icon="‚ÑπÔ∏è")
        
    if duration:
        st.empty().success(message)
        time.sleep(duration)
        st.empty()

def show_operation_status(operation_name: str, success: bool = True):
    """
    Show operation status with appropriate styling.
    
    Args:
        operation_name: Name of the operation
        success: Whether operation was successful
    """
    if success:
        st.success(f"{operation_name} completed successfully!", icon="‚úÖ")
    else:
        st.error(f"{operation_name} failed. Please try again.", icon="üö®")
========================================

File Name: streamlit\components\__init__.py
========================================

========================================

File Name: streamlit\pages\01_Database_Operations.py
========================================
import streamlit as st
import sys
from pathlib import Path
import time

# Add the parent directory to sys.path
sys.path.append(str(Path(__file__).parent.parent))

from utils.api import ChromaDBClient
from components.status import show_status_message, show_operation_status
from config import DB_ENDPOINTS

def init_page():
    st.set_page_config(
        page_title="Database Operations",
        page_icon="üóÑÔ∏è",
        layout="wide"
    )
    st.title("ChromaDB Operations üóÑÔ∏è")
    
    # Initialize API client
    return ChromaDBClient(DB_ENDPOINTS)

def render_database_section(client: ChromaDBClient):
    """Render database initialization section"""
    st.header("Database Management")
    
    if st.button("Initialize Database", type="primary"):
        try:
            response = client.create_database()
            show_operation_status("Database initialization")
        except Exception as e:
            show_status_message(f"Error initializing database: {str(e)}", type="error")

def render_collections_section(client: ChromaDBClient):
    """Render collections management section"""
    st.header("Collections Management")
    
    # Create collection
    with st.expander("Create New Collection", expanded=False):
        col_name = st.text_input("Collection Name")
        if st.button("Create Collection", disabled=not col_name):
            try:
                response = client.create_collection(col_name)
                show_operation_status("Collection creation")
                time.sleep(1)  # Small delay to ensure UI update
                st.rerun()  # Updated from experimental_rerun()
            except Exception as e:
                show_status_message(f"Error creating collection: {str(e)}", type="error")
    
    # List and manage collections
    st.subheader("Existing Collections")
    try:
        response = client.list_collections()
        collections = response.get("collections", [])
        
        if not collections:
            st.info("No collections found. Create one above! üëÜ")
        else:
            for col in collections:
                col1, col2 = st.columns([3, 1])
                with col1:
                    st.write(f"üìÅ {col}")
                with col2:
                    if st.button("Delete", key=f"del_{col}", type="secondary"):
                        try:
                            if st.session_state.get(f"confirm_delete_{col}"):
                                response = client.delete_collection(col)
                                show_operation_status("Collection deletion")
                                st.session_state[f"confirm_delete_{col}"] = False
                                time.sleep(1)  # Small delay to ensure UI update
                                st.rerun()  # Updated from experimental_rerun()
                            else:
                                st.session_state[f"confirm_delete_{col}"] = True
                                show_status_message(
                                    f"‚ö†Ô∏è Click again to confirm deletion of collection '{col}'",
                                    type="warning"
                                )
                        except Exception as e:
                            show_status_message(
                                f"Error deleting collection: {str(e)}",
                                type="error"
                            )
                            st.session_state[f"confirm_delete_{col}"] = False
    except Exception as e:
        show_status_message(f"Error listing collections: {str(e)}", type="error")

def main():
    client = init_page()
    
    # Render main sections
    render_database_section(client)
    st.divider()
    render_collections_section(client)

if __name__ == "__main__":
    main()
========================================

File Name: streamlit\pages\02_Chroma_Index_Operations.py
========================================
import streamlit as st
import sys
from pathlib import Path
import time
import os
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Add the parent directory to sys.path
sys.path.append(str(Path(__file__).parent.parent))

from utils.api import ChromaIndexClient, GDriveClient
from utils.file_utils import FileManager
from components.status import show_status_message, show_operation_status
from config import INDEX_ENDPOINTS, GDRIVE_ENDPOINTS

def init_page():
    st.set_page_config(
        page_title="Index Operations",
        page_icon="üìë",
        layout="wide"
    )
    st.title("Document Processing & Index Operations üìë")
    
    # Check for auth callback
    if st.query_params.get("auth_success"):
        st.session_state.drive_authorized = True
        st.query_params.clear()
    
    # Initialize API clients
    index_client = ChromaIndexClient(INDEX_ENDPOINTS)
    gdrive_client = GDriveClient(GDRIVE_ENDPOINTS)
    
    return index_client, gdrive_client

def check_drive_auth():
    """Check if already authorized with Google Drive"""
    return os.path.exists('token.pickle')

def render_gdrive_section(gdrive_client: GDriveClient):
    """Render Google Drive integration section"""
    st.header("Google Drive Integration")
    
    # Initialize session state for drive authorization
    if "drive_authorized" not in st.session_state:
        st.session_state.drive_authorized = check_drive_auth()
    
    # Step 1: Authorization
    if not st.session_state.drive_authorized:
        st.write("üîê Connect to Google Drive to access your files")
        if st.button("Connect to Google Drive", type="primary"):
            try:
                auth_url = gdrive_client.get_auth_url()
                st.markdown(
                    """
                    1. Click the link below to authorize access to Google Drive
                    2. After authorization, you'll be redirected back automatically
                    """
                )
                st.markdown(f"[Click here to authorize]({auth_url})")
            except Exception as e:
                show_status_message(f"Error connecting to Google Drive: {str(e)}", type="error")
        return
    
    # Step 2: Folder Selection (only shown after authorization)
    st.success("‚úÖ Connected to Google Drive")
    
    with st.form("folder_form"):
        folder_id = st.text_input(
            "Folder ID",
            help="Enter the Google Drive folder ID containing your PDFs"
        )
        submit_button = st.form_submit_button("Download Files", type="primary")
    
    # Process download outside the form to maintain success message
    if submit_button and folder_id:
        try:
            with st.spinner("Downloading files from Drive..."):
                response = gdrive_client.download_files(folder_id)
                if response and isinstance(response, dict) and response.get("files"):
                    downloaded_files = response["files"]
                    st.session_state.downloaded_files = downloaded_files
                    file_count = len(downloaded_files)
                    logger.info(f"Downloaded files: {downloaded_files}")
                    
                    # Create success message with file names using markdown
                    success_msg = [
                        f"‚ú® Successfully downloaded {file_count} document{'s' if file_count > 1 else ''}:",
                        "",  # Empty line for spacing
                        *[f"* {file}" for file in downloaded_files]
                    ]
                    st.success("\n".join(success_msg))
                else:
                    st.info("No files found in the specified folder")
        except Exception as e:
            show_status_message(f"Error downloading files: {str(e)}", type="error")

def render_local_upload():
    """Render local file upload section"""
    st.header("Local File Upload")
    
    # Initialize session state
    if "upload_status" not in st.session_state:
        st.session_state.upload_status = {"completed": False, "files": set()}
    
    uploaded_files = st.file_uploader(
        "Upload PDF files",
        type=["pdf"],
        accept_multiple_files=True,
        key="file_uploader"
    )
    
    if uploaded_files:
        # Get filenames of newly uploaded files
        current_files = {f.name for f in uploaded_files}
        new_files = current_files - st.session_state.upload_status["files"]
        
        if new_files:  # Only process new files
            with st.spinner("Copying files to raw data directory..."):
                uploaded_count = 0
                for file in uploaded_files:
                    if file.name in new_files:
                        try:
                            FileManager.save_uploaded_file(file)
                            uploaded_count += 1
                            st.session_state.upload_status["files"].add(file.name)
                        except Exception as e:
                            show_status_message(f"Error saving file {file.name}: {str(e)}", type="error")
                            continue
                
                if uploaded_count > 0:
                    show_status_message(f"Successfully uploaded {uploaded_count} files", type="success")
    
    # Clear status when no files are selected
    elif st.session_state.upload_status["files"]:
        st.session_state.upload_status = {"completed": False, "files": set()}
        
def render_available_documents():
    """Render available documents section"""
    st.subheader("Available Documents")  # Changed from header to subheader
    
    # Get files from raw data directory
    available_files = FileManager.get_raw_data_files()
    
    if not available_files:
        st.info("No documents available. Upload files or download from Google Drive.")
        return []
    
    st.write(f"Found {len(available_files)} documents in raw data directory:")
    
    # Create checkboxes for file selection with two columns
    col1, col2 = st.columns(2)
    
    selected_files = []
    for idx, file in enumerate(sorted(available_files)):
        # Alternate between columns
        with col1 if idx % 2 == 0 else col2:
            if st.checkbox(f"üìÑ {file}", key=f"file_{file}"):
                file_path = FileManager.get_file_path(file)
                if FileManager.is_valid_pdf(file_path):
                    selected_files.append(file_path)
                else:
                    st.warning(f"Invalid or missing file: {file}")
    
    return selected_files

def render_collection_documents(client: ChromaIndexClient, collection_name: str):
    """Render documents in collection"""
    try:
        # Get document count
        count = client.count_documents(collection_name)
        total_docs = count.get("count", 0)
        st.metric("Total Chunks in Collection", total_docs)
        
        # Search functionality for viewing documents
        st.subheader("Indexed Documents")
        if total_docs > 0:
            # Create tabs for different views
            view_tab, search_tab = st.tabs(["üìö Document Overview", "üîç Search Documents"])
            
            with view_tab:
                # Get all documents (limited to recent ones to avoid overwhelming)
                results = client.search_documents(collection_name, "", min(total_docs, 100))
                if results.get("results"):
                    # Group chunks by source file
                    docs_by_file = {}
                    for doc in results["results"]:
                        source_file = doc.get("metadata", {}).get("source_file", "Unknown Source")
                        if source_file not in docs_by_file:
                            docs_by_file[source_file] = []
                        docs_by_file[source_file].append(doc)
                    
                    # Display documents grouped by file
                    for file_name, chunks in docs_by_file.items():
                        with st.expander(f"üìÑ {file_name} ({len(chunks)} chunks)"):
                            # Display file info
                            st.write(f"**Source File:** {file_name}")
                            # Show chunks in a scrollable container
                            for idx, chunk in enumerate(chunks, 1):
                                st.markdown("---")
                                st.write(f"**Chunk {idx}** (Page: {chunk.get('metadata', {}).get('page_number', 'Unknown')})")
                                # Create two columns: one for preview, one for "Show full content" button
                                col1, col2 = st.columns([4, 1])
                                with col1:
                                    st.text(chunk.get('page_content', '')[:200] + "...")
                                with col2:
                                    # Use a button to toggle full content visibility
                                    button_key = f"show_content_{file_name}_{idx}"
                                    if button_key not in st.session_state:
                                        st.session_state[button_key] = False
                                    if st.button("Show Full", key=f"btn_{file_name}_{idx}"):
                                        st.session_state[button_key] = not st.session_state[button_key]
                                
                                # Show full content if button was clicked
                                if st.session_state[button_key]:
                                    st.text(chunk.get('page_content', ''))
            
            with search_tab:
                # Initialize session state for search
                if 'search_query' not in st.session_state:
                    st.session_state.search_query = ''
                if 'search_results' not in st.session_state:
                    st.session_state.search_results = None
                
                # Search interface
                query = st.text_input("Search Query", key="search_input")
                k = st.slider("Number of results", min_value=1, max_value=20, value=4)
                
                # Only perform search if query changes or button is clicked
                if st.button("Search", disabled=not query) or (query != st.session_state.search_query and query):
                    try:
                        with st.spinner("Searching..."):
                            st.session_state.search_query = query
                            results = client.search_documents(collection_name, query, k)
                            st.session_state.search_results = results.get("results", [])
                    except Exception as e:
                        show_status_message(f"Error searching documents: {str(e)}", type="error")
                
                # Display results from session state
                if st.session_state.search_results:
                    for idx, doc in enumerate(st.session_state.search_results, 1):
                        st.markdown("---")
                        st.write(f"**Result {idx}**")
                        metadata = doc.get("metadata", {})
                        st.write(f"**Source:** {metadata.get('source_file', 'Unknown')}")
                        st.write(f"**Page:** {metadata.get('page_number', 'Unknown')}")
                        # Create two columns: one for preview, one for "Show full content" button
                        col1, col2 = st.columns([4, 1])
                        with col1:
                            st.text(doc.get('page_content', '')[:200] + "...")
                        with col2:
                            # Use a button to toggle full content visibility
                            button_key = f"show_search_{query}_{idx}"
                            if button_key not in st.session_state:
                                st.session_state[button_key] = False
                            if st.button("Show Full", key=f"btn_search_{query}_{idx}"):
                                st.session_state[button_key] = not st.session_state[button_key]
                        
                        # Show full content if button was clicked
                        if st.session_state[button_key]:
                            st.text(doc.get('page_content', ''))
                elif st.session_state.search_query:
                    st.info("No results found")
                    
        else:
            st.info("Collection is empty. Process some documents to see them here.")
            
    except Exception as e:
        logger.error(f"Error fetching collection documents: {str(e)}", exc_info=True)
        show_status_message(f"Error fetching collection documents: {str(e)}", type="error")

def render_document_processing(client: ChromaIndexClient):
    """Render document processing section"""
    st.header("Document Processing")
    
    # Collection selection for processing
    collection_name = st.text_input("Target Collection Name")
    if not collection_name:
        st.warning("Please enter a collection name to process documents")
        return
        
    # Show current collection documents
    st.subheader(f"Current Documents in {collection_name}")
    render_collection_documents(client, collection_name)
    
    # Process new documents
    st.subheader("Process New Documents")
    selected_files = render_available_documents()
    
    if selected_files:
        num_selected = len(selected_files)
        container = st.container()
        with container:
            st.write(f"Selected {num_selected} document{'s' if num_selected > 1 else ''} for processing")
            col1, col2 = st.columns([1, 4])  # Use columns to align button to the left
            with col1:
                if st.button("Process Files", type="primary"):
                    try:
                        with st.spinner(f"Processing {num_selected} files..."):
                            logger.info(f"Starting to process {num_selected} files for collection {collection_name}")
                            response = client.process_pdfs(collection_name, selected_files)
                            if response.get("message"):
                                show_operation_status(response["message"])
                            else:
                                show_operation_status("File processing")
                            logger.info("File processing completed successfully")
                            time.sleep(1)  # Small delay to ensure UI updates
                            st.rerun()  # Refresh to show updated collection documents
                    except ValueError as e:
                        error_msg = str(e)
                        logger.error(f"Validation error: {error_msg}")
                        show_status_message(error_msg, type="error")
                    except Exception as e:
                        error_msg = str(e)
                        logger.error(f"Error processing files: {error_msg}", exc_info=True)
                        show_status_message(f"Error processing files: {error_msg}", type="error")
    else:
        st.info("Select documents to process from the list above")

def main():
    index_client, gdrive_client = init_page()
    
    # Main sections
    render_gdrive_section(gdrive_client)
    st.divider()
    render_local_upload()
    st.divider()
    render_document_processing(index_client)

if __name__ == "__main__":
    main()
========================================

File Name: streamlit\pages\03_Agent_Chat.py
========================================

========================================

File Name: streamlit\pages\__init__.py
========================================

========================================

File Name: streamlit\utils\api.py
========================================
import requests
from typing import Optional, Dict, Any, List
import logging
from pathlib import Path
import os
from contextlib import ExitStack

logger = logging.getLogger(__name__)

class APIClient:
    @staticmethod
    def make_request(
        method: str,
        url: str,
        params: Optional[Dict[str, Any]] = None,
        json: Optional[Dict[str, Any]] = None,
        files: Optional[Dict[str, Any]] = None,
        raise_for_status: bool = True
    ) -> Dict[str, Any]:
        """Make a request to the API endpoint."""
        try:
            response = requests.request(
                method=method,
                url=url,
                params=params,
                json=json,
                files=files
            )
            
            if raise_for_status:
                response.raise_for_status()
                
            return response.json()
        except requests.exceptions.RequestException as e:
            logger.error(f"API request failed: {str(e)}")
            raise

class ChromaDBClient:
    """Client for ChromaDB API operations"""
    
    def __init__(self, endpoints: Dict[str, str]):
        self.endpoints = endpoints
        
    def create_database(self) -> Dict[str, str]:
        """Initialize ChromaDB database"""
        return APIClient.make_request("POST", self.endpoints["create"])
    
    def delete_database(self) -> Dict[str, str]:
        """Delete ChromaDB database"""
        return APIClient.make_request("DELETE", self.endpoints["delete"])
    
    def create_collection(self, collection_name: str) -> Dict[str, str]:
        """Create a new collection"""
        url = f"{self.endpoints['create_collection']}/{collection_name}"
        return APIClient.make_request("POST", url)
    
    def delete_collection(self, collection_name: str) -> Dict[str, str]:
        """Delete a collection"""
        url = f"{self.endpoints['delete_collection']}/{collection_name}"
        return APIClient.make_request("DELETE", url)
    
    def list_collections(self) -> Dict[str, list]:
        """List all collections"""
        return APIClient.make_request("GET", self.endpoints["list_collections"])

class ChromaIndexClient:
    """Client for Chroma indexing operations"""
    
    def __init__(self, endpoints: Dict[str, str]):
        self.endpoints = endpoints
        
    def process_pdfs(self, collection_name: str, file_paths: List[str]) -> Dict[str, str]:
        """Process PDF files and add to collection"""
        url = f"{self.endpoints['process_pdfs']}/{collection_name}/process_pdfs"
        
        # Use ExitStack to manage multiple file handles
        with ExitStack() as stack:
            files = []
            for file_path in file_paths:
                try:
                    # Ensure we have absolute path
                    abs_path = os.path.abspath(file_path)
                    if os.path.exists(abs_path) and abs_path.lower().endswith('.pdf'):
                        # Open file and add to stack
                        f = stack.enter_context(open(abs_path, 'rb'))
                        filename = os.path.basename(abs_path)
                        files.append(('files', (filename, f, 'application/pdf')))
                    else:
                        logger.warning(f"Skipping invalid file: {file_path}")
                except Exception as e:
                    logger.error(f"Error processing file {file_path}: {str(e)}")
                    raise
            
            if not files:
                raise ValueError("No valid PDF files to process")
            
            # Make the request with all files open
            return APIClient.make_request("POST", url, files=files)
    
    def search_documents(self, collection_name: str, query: str, k: int = 4) -> Dict[str, List]:
        """Search documents in collection"""
        url = f"{self.endpoints['search']}/{collection_name}/search"
        return APIClient.make_request("GET", url, params={"query": query, "k": k})
    
    def count_documents(self, collection_name: str) -> Dict[str, int]:
        """Get document count in collection"""
        url = f"{self.endpoints['count']}/{collection_name}/count"
        return APIClient.make_request("GET", url)
    
    def add_documents(self, collection_name: str, documents: List[Dict[str, Any]]) -> Dict[str, str]:
        """Add documents to collection"""
        url = f"{self.endpoints['add_documents']}/{collection_name}/add_documents"
        return APIClient.make_request("POST", url, json=documents)
    
    def delete_document(self, collection_name: str, document_id: str) -> Dict[str, str]:
        """Delete document from collection"""
        url = f"{self.endpoints['delete_document']}/{collection_name}/documents/{document_id}"
        return APIClient.make_request("DELETE", url)
    
    def update_document(self, collection_name: str, document_id: str, document: Dict[str, Any]) -> Dict[str, str]:
        """Update document in collection"""
        url = f"{self.endpoints['update_document']}/{collection_name}/documents/{document_id}"
        return APIClient.make_request("PUT", url, json=document)

class GDriveClient:
    """Client for Google Drive operations"""
    
    def __init__(self, endpoints: Dict[str, str]):
        self.endpoints = endpoints
        
    def get_auth_url(self) -> str:
        """Get Google Drive authorization URL"""
        return self.endpoints["authorize"]
    
    def download_files(self, folder_id: str) -> Dict[str, Any]:
        """Download files from Google Drive folder"""
        url = f"{self.endpoints['download_files']}/{folder_id}"
        return APIClient.make_request("GET", url)
========================================

File Name: streamlit\utils\file_utils.py
========================================
import os
import shutil
from pathlib import Path
from typing import List, Set
import logging

logger = logging.getLogger(__name__)

class FileManager:
    RAW_DATA_DIR = "data/raw_data"
    
    @classmethod
    def ensure_raw_data_dir(cls):
        """Ensure the raw data directory exists"""
        os.makedirs(cls.RAW_DATA_DIR, exist_ok=True)
    
    @classmethod
    def get_raw_data_files(cls) -> Set[str]:
        """Get list of files in raw data directory"""
        cls.ensure_raw_data_dir()
        return {f for f in os.listdir(cls.RAW_DATA_DIR) if f.lower().endswith('.pdf')}
    
    @classmethod
    def save_uploaded_file(cls, file) -> str:
        """Save an uploaded file to raw data directory"""
        try:
            cls.ensure_raw_data_dir()
            file_path = os.path.join(cls.RAW_DATA_DIR, file.name)
            
            # If file exists, add a number to the filename
            base_name, extension = os.path.splitext(file.name)
            counter = 1
            while os.path.exists(file_path):
                new_name = f"{base_name}_{counter}{extension}"
                file_path = os.path.join(cls.RAW_DATA_DIR, new_name)
                counter += 1
            
            # Save the file
            with open(file_path, "wb") as f:
                f.write(file.getvalue())
            
            logger.info(f"Successfully saved file to {file_path}")
            return file_path
            
        except Exception as e:
            logger.error(f"Error saving file {file.name}: {str(e)}")
            raise
    
    @classmethod
    def get_file_path(cls, filename: str) -> str:
        """Get full path for a file in raw data directory"""
        return os.path.join(cls.RAW_DATA_DIR, filename)
    
    @classmethod
    def is_valid_pdf(cls, file_path: str) -> bool:
        """Check if a file is a valid PDF"""
        return os.path.exists(file_path) and file_path.lower().endswith('.pdf')
========================================

File Name: streamlit\utils\__init__.py
========================================

========================================

